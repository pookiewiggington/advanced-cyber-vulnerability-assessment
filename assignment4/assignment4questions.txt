Nicholas Villemez

1. How does this program accept input from a user?
The program accepts input by selecting an option from a list of options to add item, remove item,
list item, edit item, load items, save items, or quit. When selecting add item, the program reads input
using fgets and in program b using an edited fgets function.

2. Describe the vulnerability present in this program.
The vulnerability present in both functions is a tcache vulnerability. When an item is entered and subsequently freed,
a pointer to the data is written to tcache. This pointer can be overwritten to point to a GOT table entry.
When another item is added, this pointer is selected to write data to under the assumption that it is the previously
freed memory block. However, when the pointer is replaced by overwriting it with a GOT entry, adding a new item
will write to the GOT table instead of the old memory block. This GOT table entry can then be changed to point
to libc system. If the correct GOT entry is selected, then /bin/sh can be passed to this function, which system 
will execute when called. In my case, I saw that the edit function calls strchr with the data specified via the command line.
This is the GOT table entry I decided to overwrite, although I suspect that fprintf could have also been used. However,
fprintf was lower in the GOT table than strchr, so overwriting it would likely have ruined other GOT entries and been more difficult.

The House of Force vulnerability is not present in program a, but only in program b. Program a checks the size of the input
in the add function, so to specify a malloc size, that amount of data must actually be written. The amount of data
that needs to be written is too large. In program b, this check does not exist though, so a house of force can be used
as an input to wrap around to overwrite the GOT entry in the same manner as the tcache vulnerability, just using the malloc
function to do the overwrite.


3. Discuss any restrictions on the user's input that must be taken into account when attempting to
trigger the vulnerability.
In program 4a, the size of the input is compared to the specified size, so the input must
be the same size as specified. This is not the case in 4b, so both a tcache and a house of force
vulnerability are present.

4. Discuss the structure of a user input that will successfully avoid any restrictions and allow you
to successfully take control of this program. Be as detailed as possible (size, format,
content

A user input that will successfully avoid any restrictions and allow you to successfully take control of the program
is to add two items, then free the second one. This puts a pointer into tcache. Then you can edit the first
item to overflow into the memory that was allocated for the second item. This can be used to place the targeted GOT
address into the old second items memory space and overwrite the tcache pointer with the GOT table address.
The GOT address must subtract 16 bytes though to account for the prev and next 8 byte pointers. Each item I added 
was 10, plus the 16 byte prev and next pointers, and 8 bytes from malloc, rounded up to the nearest multiple of 16, 
so each block for the items was 48. This means to overwrite from the first data block into the next pointer block,
I needed to write 32 bytes and then enter the target GOT address - 16 bytes. Now that the pointer is in place to be written,
I added another item, which grabbed the first tcache pointer to add a second node back into the linked list. This revealed
the GOT table pointer as the tcache pointer, so when I added another node, the program grabbed the GOT pointer instead of
the memory for the third node. I then entered the system address at the desired GOT table entry, so when strchr would be
called, it would call system instead. After that, I found a function where strchr is called, edit, and called that. The
edit function takes data from the command line and passes it so strchr, so when I entered /bin/sh, it passed that as an
argument to system instead of strchr, giving control of the program.

6. For the exploit you develop make diagrams of the heap layout following each malloc and free
operation. The diagrams must clearly show each allocated and free block in the heap. The
diagram need not be to scale; I am particularly interested in the sequence of the blocks in the
heap, including their exact sizes and addresses.

malloc first item

    tcache
    null

    heap
    first item (no pointers prev or next)
    0x603260:       0x0000000000000000      0x0000000000000000
    0x603270:       0x4141414141414141      0x0000000000004141

malloc second item

    tcache
    null

    heap
    first item
    0x603260:       0x0000000000603290      0x0000000000000000 - next pointer now filled in
    0x603270:       0x4141414141414141      0x0000000000004141
    0x603280:       0x0000000000000000      0x0000000000000031 - size
    second item
    0x603290:       0x0000000000000000      0x0000000000603260- prev pointer
    0x6032a0:       0x4242424242424242      0x0000000000004242

free second item

    tcache
    0x603010:       0x0000000000000100      0x0000000000000000 - number in list
    0x603020:       0x0000000000000000      0x0000000000000000
    0x603030:       0x0000000000000000      0x0000000000000000
    0x603040:       0x0000000000000000      0x0000000000000000
    0x603050:       0x0000000000000000      0x0000000000603290 - tcache pointer

    heap
    first item
    0x603260:       0x0000000000000000      0x0000000000000000
    0x603270:       0x4141414141414141      0x0000000000004141
    0x603280:       0x0000000000000000      0x0000000000000031 - size
    second item (freed)
    0x603290:       0x0000000000000000      0x0000000000603010- pointer points to tcache
    0x6032a0:       0x4242424242424242      0x0000000000004242

overwrite first item into second

    tcache
    0x603010:       0x0000000000000100      0x0000000000000000 - still 1 in list
    0x603020:       0x0000000000000000      0x0000000000000000
    0x603030:       0x0000000000000000      0x0000000000000000
    0x603040:       0x0000000000000000      0x0000000000000000
    0x603050:       0x0000000000000000      0x0000000000603290 - pointer has iterated, this is what will be edited during the next add

    heap
    first item (A's overflowed into next space)
    0x603260:       0x0000000000000000      0x0000000000000000
    0x603270:       0x4141414141414141      0x4141414141414141
    0x603280:       0x4141414141414141      0x0000000000000031 - size filled in
    second item (next pointer overwritten with target GOT address - 16 bytes)
    0x603290:       0x0000000000602040      0x000000000060000a
    0x6032a0:       0x4242424242424242      0x0000000000004242

add misc second item again to iterate tcache pointer

    tcache
    0x603010:       0x0000000000000000      0x0000000000000000
    0x603020:       0x0000000000000000      0x0000000000000000
    0x603030:       0x0000000000000000      0x0000000000000000
    0x603040:       0x0000000000000000      0x0000000000000000
    0x603050:       0x0000000000000000      0x0000000000602040 - now tcache pointer points to desired editing location in GOT

    heap
    first item
    0x603260:       0x0000000000603290      0x0000000000000000
    0x603270:       0x4141414141414141      0x4141414141414141
    0x603280:       0x4141414141414141      0x0000000000000031
    second item (edited because of tcache pointer)
    0x603290:       0x0000000000000000      0x0000000000603260
    0x6032a0:       0x4343434343434343      0x0000000000004343


add system address

    tcache
    0x603010:       0x000000000000ff00      0x0000000000000000
    0x603020:       0x0000000000000000      0x0000000000000000
    0x603030:       0x0000000000000000      0x0000000000000000
    0x603040:       0x0000000000000000      0x0000000000000000
    0x603050:       0x0000000000000000      0x00007ffff7b704d0

    heap
    first item
    0x603260:       0x0000000000603290      0x0000000000000000
    0x603270:       0x4141414141414141      0x4141414141414141
    0x603280:       0x4141414141414141      0x0000000000000031
    second item
    0x603290:       0x0000000000602040      0x0000000000603260 - now next pointer points to GOT because that was edited
    0x6032a0:       0x4343434343434343      0x0000000000004343

    Now the GOT holds the following system call at the address for strchr
    0x602050:       0x00007ffff7a31550

then everything is in place to call /bin/sh via strchr in the edit function


7. Describe all locations that are candidates for the target of your arbitrary write. List only those
locations that might successfully be used to transfer control to your payload. Describe each
location in as much detail as possible including information such as the address of the location,
the purpose of the location, and the program section in which the location resides.
The locations that are candidates for the target of the GOT overwrite include
strchr
fopen
fgets
strcmp

Each of these functions is called in the programs and passes data from the command line to them.
Since data is passed through the command line as the first argument, if the GOT entries for these functions
are overwritten with a call to system instead of the intended function and /bin/sh is passed as the first argument,
then this will give a shell providing control to the payload.


9. Provide detailed instructions for executing your attack. If you use a bind shell you must
indicate what port the shell will bind to. If you use a callback you must indicate what port your
payload will call back to as well as the exact byte offset in your payload at which the 4 byte
callback IP may be found so that it may be replaced as necessary. Provide any additional details
that you think someone running your exploit might find useful.

To execute the attack, run exploit.py target_ip target_port a to exploit program a
and exploit.py target_ip target_port b to exploit program b