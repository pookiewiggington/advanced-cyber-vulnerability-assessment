Assignment 3
Nicholas Villemez

1. How does this program accept input from a user?
The program accepts input from the user on the command line after asking for a move on the
tic tac toe board. Then, if the user wins, they can enter their name into the record book and then view the record book.
The program takes input using the scanf and getchar function.

2. Describe the vulnerability present in this program.
There is a format string vulnerability when you enter the name into the permanent record book and 
then when it prints out the buffer after choosing to see the entry in the record book because it uses the
fprintf function. This fprintf function can be used to leak information and write values to memory.


3. Discuss any restrictions on the user's input that must be taken into account when
attempting to trigger the vulnerability.
You cannot input items other than numbers in a single string without spaces in the regular game play when choosing a 
move on the board. 
e.g.
1234

You can overwrite previously selected positions from the board and user. You can also input
hexadecimal values in little endian format as long as they begin with a number in the valid range after the number
e.g. 1/x41/x41/x41/x41

You can also input any value as long as there is a space between the number and that value.
e.g.
1 badvalue

Any format input is allowed when entering a name into the permanent record book to take advantage of
the format string vulnerability.


4. Discuss the structure of a user input that will successfully avoid any such restrictions and
allow you to successfully take control of this program. Be as detailed as possible (size,
format, content â€¦). Make sure you detail exactly what you are overwriting in order to
take control of the vulnerable application.

In order to take control of the vulnerable application, a user can input values in the format
'%numberc%location$hn' where number is the decimal value of the hexadecimal number that you want to write
and location is the number that points to the pointer of the address you want to write the 
hex value to. The location is 1 per 8 bytes into the buffer holding the string. To take control of the program,
you can overwrite a GOT table entry for one of the c functions with a pointer to shellcode. You need to write 
3 values in order to do this, each pointing to 2 bytes to write to. This will write a 6 byte memory address
in total using the format %number1c%location1$hn%number2c%location2$hn%number3c%location3$hn+location1+location2+location3+nops+shellcode. The address you
are pointing to is the got table entry holding the pointer to the c function, which you are
replacing with a pointer to shellcode to take control of the program. Depending on the size of the numbers, the 
 format string should be under 40 bytes, so adding padding that brings the format string to 40 bytes will perform the 
 necessary stack alignment. Then, as long as the decimal numbers being written point to a value
 in the nop sled (with a nop sled of 88 bytes, this will be between 64 and 152 bytes from the start of the buffer address),
 when the program executes the targeted c function, it will point to the nop and shellcode instead.
 In this assignment, I overwrote the exit function to loop back to main, identify a leak,
 and then overwrite the fclose GOT entry with the shellcode pointer.


5. Develop an exploit that injects reverse/callback shellcode as part of the user supplied
input and transfers control to that shell code. You must utilize shellcode that results in an
interactive shell. Your shellcode must not depend on the presence of any executable other
than /bin/sh. In particular, do not rely on the presence of netcat. As with assignment two ,
you will be given one chance to utilize information from gdb on the target to update any
addresses in your payload in the event that your exploit demonstration fail s on the first
attempt. Updating your payload may be somewhat more involved than it was on
assignment 2 , so practicing such an update is highly recommended before you schedule a
demonstration time.


6. Discuss a target independent means of determining the location of your shellcode. In
other words, if you knew a target was running this service, but you had no idea where
your shellcode would end up in memory, how would you go about determining the
address at which your shellcode is likely to land so that you could successfully exploit the
target (remember you don't get to run a debugger on the target in this case, all you get to
do is connect to and interact with the service. Think information leak here).

A target independent means of determining the location of shellcode is to identify the distance
offset between the leak and the shellcode or nop sled inside the buffer. In my case, I identified that the 
leak provided from %6$p input to the program revealed an address close to the buffer relative to the other
leaked addresses. Subtracting 512 bytes from this leak address resulted in an address that landed in
my nop sled, which is 88 bytes long. By dynamically grabbing the leaked address and calculating the distance
to the shellcode or nop sled, you can get a target independent means of determining the shellcodes
location on a target.